name: "Classroom Autograder – Unit 8.4: Iteration (Guessing Game)"

on:
  push:
  pull_request:

jobs:
  autograde:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show repo files (debug)
        run: |
          echo "Repo tree:"
          ls -la
          echo ""
          echo "Root index.html?"; [ -f index.html ] && echo "yes" || echo "no"
          echo "Root script.js?";  [ -f script.js ] && echo "yes" || echo "no"
          echo "public/index.html?"; [ -f public/index.html ] && echo "yes" || echo "no"
          echo "src/index.html?";    [ -f src/index.html ] && echo "yes" || echo "no"
          echo "docs/index.html?";   [ -f docs/index.html ] && echo "yes" || echo "no"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install test dependencies
        run: |
          npm init -y >/dev/null 2>&1 || true
          npm install --save-dev jest@29 jsdom@21 jest-environment-jsdom@29

      - name: Create Jest setup
        run: |
          cat > jest.setup.cjs <<'EOF'
          const { TextEncoder, TextDecoder } = require('util');
          if (typeof global.TextEncoder === 'undefined') global.TextEncoder = TextEncoder;
          if (typeof global.TextDecoder === 'undefined') global.TextDecoder = TextDecoder;
          EOF

      - name: Create Jest config (match only *.test.cjs)
        run: |
          cat > jest.config.cjs <<'EOF'
          module.exports = {
            testEnvironment: 'jsdom',
            setupFiles: ['<rootDir>/jest.setup.cjs'],
            testMatch: ['**/__tests__/**/*.test.cjs']
          };
          EOF

      - name: Create Jest tests (sanity + main)
        run: |
          mkdir -p __tests__

          # --- sanity test (ensures not 0/0) ---
          cat > __tests__/sanity.test.cjs <<'EOF'
          test('sanity: jest is running', () => {
            expect(true).toBe(true);
          });
          EOF

          # --- guessing game tests (string/number tolerant selection + tries) ---
          cat > __tests__/guessing.test.cjs <<'EOF'
          const fs = require('fs');
          const path = require('path');
          const { JSDOM, VirtualConsole } = require('jsdom');

          const wait = (ms=60) => new Promise(r => setTimeout(r, ms));
          const norm = s => (s || '').toLowerCase();
          const isWin = s => /win|correct|you.*got|right|nice/.test(norm(s));
          const firstInt = s => {
            const m = (s || '').match(/-?\d+/);
            return m ? Number(m[0]) : 0;
          };

          function findPath(cands){ for (const p of cands) if (fs.existsSync(p)) return p; return null; }
          function findIndexPath(){ return findPath(['index.html','public/index.html','src/index.html','docs/index.html']); }
          function findScriptPath(){ return findPath(['script.js','public/script.js','src/script.js','docs/script.js']); }

          function textOf(doc,id){ const el = doc.getElementById(id); return (el?.textContent || el?.innerText || '').trim(); }
          function setVal(doc,id,v){ const el = doc.getElementById(id); if (!el) return false; el.value = String(v); return true; }
          function callRun(win){ try { win.eval('if (typeof runJS==="function"){ runJS(); }'); } catch {} if (typeof win.runJS === 'function') win.runJS(); }

          async function loadDOM() {
            const idx = findIndexPath();
            const vconsole = new VirtualConsole();
            vconsole.on('error', () => {}); // keep CI quiet

            if (!idx) {
              // Minimal DOM so tests fail gracefully instead of aborting
              const dom = new JSDOM('<!doctype html><html><body></body></html>', {
                url: 'file:///tmp/',
                runScripts: 'dangerously',
                resources: 'usable',
                pretendToBeVisual: true,
                virtualConsole: vconsole
              });
              dom.window.__MISSING_INDEX__ = true;
              dom.window.__MISSING_SCRIPT__ = !findScriptPath();
              return dom;
            }

            const baseDir = path.dirname(path.resolve(idx));
            const baseUrl = 'file://' + baseDir.replace(/\\+/g,'/') + '/';

            const dom = await JSDOM.fromFile(idx, {
              url: baseUrl,
              runScripts: 'dangerously',
              resources: 'usable',
              pretendToBeVisual: true,
              virtualConsole: vconsole
            });

            dom.window.alert = () => { throw new Error('Use textContent, not alert().'); };
            dom.window.prompt = () => { throw new Error('Use inputs, not prompt().'); };

            await new Promise(res => dom.window.addEventListener('load', res, { once: true }));
            await wait();
            return dom;
          }

          // Try 1..10, returning detailed trace
          async function play(window, document) {
            callRun(window); // start
            await wait();

            const trace = []; // [{g, feedback, tries}]
            for (let g = 1; g <= 10; g++) {
              setVal(document, 'guess', g);
              callRun(window);
              await wait();
              trace.push({
                g,
                feedback: textOf(document,'feedback'),
                tries: textOf(document,'tries')
              });
              if (isWin(trace[trace.length-1].feedback)) break;
            }
            return trace;
          }

          describe('Unit 8.4 – Iteration Guessing Game', () => {
            let dom, window, document;

            beforeAll(async () => {
              dom = await loadDOM();
              window = dom.window;
              document = dom.window.document;
            });

            test('has required elements (#guess, #feedback, #tries, #hintList) and button', () => {
              if (window.__MISSING_INDEX__) throw new Error('index.html not found (root/public/src/docs).');
              expect(document.getElementById('guess')).not.toBeNull();
              expect(document.getElementById('feedback')).not.toBeNull();
              expect(document.getElementById('tries')).not.toBeNull();
              expect(document.getElementById('hintList')).not.toBeNull();
              expect(document.querySelector('button')).not.toBeNull();
            });

            test('does not use prompt/alert (uses inputs + textContent)', () => {
              if (window.__MISSING_INDEX__) throw new Error('index.html missing');
              expect(true).toBe(true);
            });

            test('invalid input shows an "invalid" message in #feedback', async () => {
              if (window.__MISSING_INDEX__) throw new Error('index.html missing');
              callRun(window); await wait();
              setVal(document,'guess','abc');
              callRun(window); await wait();
              expect(norm(textOf(document,'feedback'))).toMatch(/invalid/);
            });

            // RELAXED + TOLERANT:
            // passes if we observe any non-empty, non-win feedback BEFORE a win
            // OR if the tries numeric value increases BEFORE win (progress signal).
            test('selection logic works (non-win feedback then win)', async () => {
              if (window.__MISSING_INDEX__) throw new Error('index.html missing');
              const t0Text = textOf(document,'tries'); // pre-start read (may be "")
              const t0 = firstInt(t0Text);

              const trace = await play(window, document);
              const winStep = trace.findIndex(x => isWin(x.feedback));

              expect(winStep).toBeGreaterThanOrEqual(0); // we must eventually win

              // Did we show any non-win feedback before the win?
              const hadNonWinText = trace
                .slice(0, winStep)
                .some(x => x.feedback && !isWin(x.feedback));

              // Or did the tries number increase before the win?
              let hadProgressTries = false;
              let prev = t0;
              for (const x of trace.slice(0, winStep)) {
                const n = firstInt(x.tries);
                if (n > prev) { hadProgressTries = true; break; }
                prev = n;
              }

              expect(hadNonWinText || hadProgressTries).toBe(true);
            });

            test('tries counter updates (number/string tolerant)', async () => {
              if (window.__MISSING_INDEX__) throw new Error('index.html missing');
              callRun(window); await wait();

              const id = 'tries';
              const startText = textOf(document, id);
              const start = firstInt(startText);

              // Make at least two valid guesses or until win
              let last = start;
              for (let g = 1; g <= 10; g++) {
                setVal(document,'guess', g);
                callRun(window);
                await wait();
                const now = firstInt(textOf(document, id));
                if (now > last) { last = now; }
                if (isWin(textOf(document,'feedback'))) break;
              }
              // Must have increased at least once by the end
              expect(last).toBeGreaterThan(start);
            });

            test('for-loop task: #hintList shows numbers 1..10 (on start)', async () => {
              if (window.__MISSING_INDEX__) throw new Error('index.html missing');
              callRun(window); await wait();
              const el = document.getElementById('hintList');
              expect(el).not.toBeNull();
              const kids = Array.from(el.children || []);
              const txt = (el.textContent || '').trim();
              const hasTen = kids.length >= 10;
              const found = (txt.match(/\b(?:10|[1-9])\b/g) || []).length >= 10;
              expect(hasTen || found).toBe(true);
            });

            test('script.js contains a while loop', () => {
              const p = findScriptPath();
              if (!p) throw new Error('script.js not found (root/public/src/docs).');
              const src = fs.readFileSync(p,'utf8');
              expect(/\bwhile\s*\(/.test(src)).toBe(true);
            });
          });
          EOF

      - name: List discovered tests (debug)
        run: npx jest --listTests

      - name: Run tests (always produce JSON)
        id: jest
        continue-on-error: true
        run: |
          npx jest --runInBand --json --outputFile=jest-results.json
          echo "Jest exit code: $?"
          echo "--- jest-results.json (head) ---"
          head -c 800 jest-results.json || echo "(no jest-results.json created)"

      - name: Upload raw results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jest-results
          path: jest-results.json

      - name: Summarize results for students
        if: always()
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const summary = process.env.GITHUB_STEP_SUMMARY;

          let r;
          try { r = JSON.parse(fs.readFileSync('jest-results.json','utf8')); }
          catch { r = { numTotalTests: 0, numPassedTests: 0, numFailedTests: 0, testResults: [] }; }

          const total  = r.numTotalTests ?? 0;
          const passed = r.numPassedTests ?? 0;
          const failed = r.numFailedTests ?? 0;

          const all = (r.testResults || []).flatMap(t => t.assertionResults || []);
          const txt = t => (t.title || t.fullName || '').toLowerCase();
          const ok  = k => all.some(t => txt(t).includes(k.toLowerCase()) && t.status==='passed');

          const checks = [
            {label:'has required elements', key:'has required elements'},
            {label:'no prompt/alert (uses inputs & textContent)', key:'does not use prompt/alert'},
            {label:'invalid input handled', key:'invalid input'},
            {label:'selection logic works (non-win feedback then win)', key:'selection logic'},
            {label:'tries counter updates', key:'tries counter updates'},
            {label:'for-loop task complete', key:'for-loop task'},
            {label:'while loop present in script.js', key:'contains a while loop'}
          ];

          const icon = b => b ? '✅' : '❌';

          const out = [];
          out.push(`# Unit 8.4 Autograder Summary`);
          out.push(`**Passed:** ${passed}/${total} · **Failed:** ${failed}`);
          out.push('');
          out.push('## What you got right / need to fix');
          for (const c of checks) {
            const pass = ok(c.key);
            out.push(`${icon(pass)} ${c.label}`);
            if (!pass) {
              const hints = {
                'selection logic works (non-win feedback then win)':'Show some non-win feedback before a win (a hint or message), or make sure #tries increases before win.',
                'tries counter updates':'Increase the visible #tries on valid guesses (the number is parsed even if surrounded by words).',
                'for-loop task complete':'Populate #hintList with 1–10 using a for loop.'
              };
              if (hints[c.label]) out.push(`   - Hint: ${hints[c.label]}`);
            }
          }
          out.push('');
          out.push('### Reminders');
          out.push('- One button calls runJS(): start → guess → win → reset.');
          out.push('- Use a for loop for #hintList (1–10) and a while loop to keep checking guesses.');
          out.push('- No prompt()/alert(); update the page with textContent.');

          fs.appendFileSync(summary, out.join('\n'));
          NODE

      - name: Set job status
        if: always()
        run: |
          node - <<'NODE'
          const fs = require('fs');
          let r={};
          try { r = JSON.parse(fs.readFileSync('jest-results.json','utf8')); }
          catch { r = { numTotalTests: 0, numFailedTests: 1 }; }
          const total  = r.numTotalTests ?? 0;
          const failed = r.numFailedTests ?? 0;
          if (failed > 0 || total === 0) process.exit(1);
          NODE
